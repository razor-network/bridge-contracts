// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.15;

import "./StateManager.sol";
import "../interface/IBridge.sol";
import "../interface/IStakeManager.sol";
import "../interface/IBlameManager.sol";
import "../Storage/BridgeStorage.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/proxy/utils/Initializable.sol";
import "../library/Random.sol";

/**
 * @notice this contract is part of the bridge ecosystem and has to be deployed on the native chain
 */
contract Bridge is BridgeStorage, StateManager, Initializable, IBridge {
    IStakeManager public stakeManager;
    IBlameManager public blameManager;
    /**
     * @dev Emitted when a chainID is supported or not supported anymore (isChainSupported)
     * @param chainId chain id to be supported
     * @param isSupported boolean that shows whether a chain id is supported or not
     * @param sender the admin address
     * @param epoch current epoch of chain id support
     * @param dynasty current dynasty of chain id support
     */

    event ChainStatus(uint256 chainId, bool isSupported, address sender, uint256 indexed epoch, uint256 indexed dynasty);

    /**
     * @dev Emitted when there has been a call to createRequest. Can only be called by the admin
     * @param numRequests number of requests so far (requestId)
     * @param sourceChainId chain id of the source from where the data is to be queried
     * @param sourceAddress smart contract address on the source chain
     * @param sourceFunctionName source parameterless function to query the function from the source smart contract
     * @param targetChainId destination chain id where the queried data is to be sent
     * @param requesterAddress address of the createRequest caller
     */
    event CreatedRequest(
        uint32 numRequests,
        uint32 sourceChainId,
        address sourceAddress,
        bytes sourceFunctionName,
        uint32 targetChainId,
        address indexed requesterAddress,
        uint256 indexed epoch,
        uint256 indexed dynasty
    );

    /**
     * @dev Emitted when validators are churned out
     * @param churnedOutValidators validators churned out for the dynasty
     * @param epoch current epoch of validatorSelection
     * @param dynasty current dynasty of validatorSelection
     */
    event ValidatorsChurnedOut(uint32[] churnedOutValidators, uint256 indexed epoch, uint256 indexed dynasty);

    /**
     * @dev Emitted when a validator takes part the validator selection process.
     * @param validatorId ID of the validator
     * @param activeSet validators selected for the dynasty
     * @param iteration value generated by the validator
     * @param isValidatorSelected if the validator has been selected
     * @param epoch current epoch of validatorSelection
     * @param dynasty current dynasty of validatorSelection
     */
    event ValidatorSelection(
        uint32 validatorId,
        uint32[] activeSet,
        uint256 iteration,
        uint256 biggestStake,
        bool isValidatorSelected,
        uint256 indexed epoch,
        uint256 indexed dynasty
    );

    /**
     * @dev Emitted when a validator tries to attest signerAddress for the first time.
     * @param signerAddress address attested by all validators
     * @param validatorId ID of the validator from the active set of validators
     * @param sender caller of the attestSigner
     * @param epoch current epoch of attestSigner
     * @param dynasty current dynasty of attestSigner
     */
    event AttestSigner(address signerAddress, uint32 indexed validatorId, address sender, uint256 indexed epoch, uint256 indexed dynasty);

    /**
     * @dev Emitted when old signer transfers ownership to the new signer address.
     * @param signature with which the message is signed by old signer address
     * @param oldSignerAddress address of the public old signer address
     * @param newSignerAddress address of the public new signer address
     * @param epoch current epoch of signerTransfer
     * @param dynasty current dynasty of signerTransfer
     */
    event ConfirmTransfer(
        bytes signature, address oldSignerAddress, address newSignerAddress, uint256 indexed epoch, uint256 indexed dynasty
    );

    /**
     * @dev Emitted when a validator tries to commit message for the first time.
     * @param message the message being committed by the validator
     * @param validatorId ID of the validator from the active set of validators
     * @param sender caller of the attestSigner
     * @param epoch current epoch of attestSigner
     * @param dynasty current dynasty of attestSigner
     */
    event MessageCommitted(bytes message, uint32 indexed validatorId, address sender, uint256 indexed epoch, uint256 dynasty);

    /**
     * @dev Emitted when a block is successfully created and finalized.
     * @param blockWinner Winner of the block reward
     * @param signature with which the message is signed
     * @param signerAddress address of the public signer address
     * @param messageData the data being finalized
     * @param sender caller of finalizeRequest ie, finalizing address
     * @param epoch current epoch of finalizeRequest
     * @param dynasty current dynasty of finalizeRequest
     */
    event FinalizeBlock(
        uint32 blockWinner,
        bytes signature,
        address signerAddress,
        bytes messageData,
        address indexed sender,
        uint256 indexed epoch,
        uint256 indexed dynasty
    );

    //Common errors
    /// @notice reverts with the error if Bridge is initialized with a zero address
    error ZeroAddress();
    /// @notice reverts with the error if validatorId is 0
    error InvalidValidator();
    /// @notice reverts with the error if ECDSA recover of the messageHash and signature are not equal to expected signer address
    error InvalidSignature();
    /// @notice reverts with the error if incorrect mode is detected, depends on current state of the network
    error IncorrectMode();
    /// @notice reverts with the error if validator tries to attest signer address or commit message without being in current active set
    error ValidatorNotSelected();
    /// @notice reverts with the error if validator tries to attest a zero address or confirmSigner when attestedSignerAddress is empty
    error ZeroSignerAddress();
    /// @notice reverts with the error if chainId status is same as the input sent
    error ChainStatusAlreadySet();
    /// @notice reverts with the error if chainId is not supported
    error UnsupportedChain();

    //Mode:ValidatorSelection errors
    /// @notice reverts with the error if threshold is set greater than or equal to the number of participants in the network
    error InvalidUpdation();
    /// @notice reverts with the error if validator has less than minStake during validator selection
    error LessThanMinStake(uint256 validatorStake);
    /// @notice reverts with the error if validator is jailed during validator selection
    error ValidatorInJailPeriod();
    /// @notice reverts with the error if validator has already called validatorSelection in the current dynasty
    error IterationAlreadyCalculated();
    /// @notice reverts with the error if validator has not been selected in the current dynasties active set
    error NotElected();

    //Mode:SignerCreation errors
    /// @notice reverts with the error if validator tries to attest a signer address more than once in an epoch
    error AlreadyAttested();
    /// @notice reverts with the error if confirmSigner is called, but the public signing address
    /// of the current dynasty has already been set
    error SignerAlreadyConfirmed();

    //Mode:Signing errors
    /// @notice reverts with the error if validator has already committed a message in the current epoch
    error ValidatorAlreadyCommitted();
    /// @notice reverts with the error if validator tries to commit a message, when the block for the epoch is already proposed
    error BlockAlreadyConfirmed();
    /// @notice reverts with the error if the messageData being sent to commitMessage or finalizeBlock is incorrect
    error InvalidMessage();
    /// @notice reverts with the error if there are no pending requests, and the message values are not empty
    /// as expected for mining an empty block
    error EmptyMessageExpected();
    /// @notice reverts with the error if there is no message attested in the current epoch, and a validator tries to finalizeBlock
    error NoMessageCommitted();
    /// @notice reverts with the error if the _dynasty in the message being committed, does not match current dynasty
    error InvalidDynastyInMessageData(uint256 dynasty, uint256 messageDynasty);
    /// @notice reverts with the error if the _epoch in the message being committed, does not match current epoch
    error InvalidEpochInMessageData(uint256 epoch, uint256 messageEpoch);
    /// @notice reverts with the error if requestId == 0 is detected within messageData
    error RequestIdCantBeZero();
    /// @notice reverts with the error if requests[requestId] is already fulfilled
    error RequestAlreadyFulfilled(uint32 requestId);
    /// @notice reverts with the error if the requests[requestId].epoch is greater than or equal to the current epoch
    error IncorrectRequestEpoch(uint256 epoch, uint256 requestEpoch);
    /// @notice reverts with the error if requestIds of messageData are not in ascending order
    error RequestIdsNotInOrder();
    /// @notice reverts with the error if the length of requestIds of messageData is greater than the maximum allowed requests; maxRequests
    error TooManyRequests();
    /// @notice reverts with the error if the if previous request is not fulfilled yet
    error PreviousRequestNotFulfilled();

    constructor() {
        firstDynastyCreation = block.timestamp;
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    /**
     * @notice creates a request that is to be fulfilled by the bridge node
     * @dev numRequests is incremented here and the request struct is set,
     *  which is later verified using requestIds to make sure the correct requests are fulfilled, sourceFunctionName is bytes("getResult()")
     * @param requesterAddress address of the requester
     * @param sourceChainId chain id of the source from where the data is to be queried
     * @param sourceAddress smart contract address on the source chain
     * @param sourceFunctionName source parameterless function to query the function from the source smart contract
     * @param targetChainId destination chain id where the queried data is to be sent
     */
    function createRequest(
        address requesterAddress,
        uint32 sourceChainId,
        address sourceAddress,
        bytes memory sourceFunctionName,
        uint32 targetChainId
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (!isChainSupported[targetChainId]) revert UnsupportedChain();
        numRequests = numRequests + 1;
        bytes memory requestData = abi.encode(requesterAddress, sourceChainId, sourceAddress, sourceFunctionName, targetChainId);
        requests[numRequests] = Structs.Request(false, numRequests, getEpoch(), requestData);
        emit CreatedRequest(
            numRequests, sourceChainId, sourceAddress, sourceFunctionName, targetChainId, msg.sender, getEpoch(), getDynasty()
            );
    }

    /**
     * @param stakeManagerAddress The address of the stake manager contract
     * @param blameManagerAddress The address of the blame manager contract
     */
    function initialize(address stakeManagerAddress, address blameManagerAddress) external initializer onlyRole(DEFAULT_ADMIN_ROLE) {
        if (stakeManagerAddress == address(0)) revert ZeroAddress();
        if (blameManagerAddress == address(0)) revert ZeroAddress();
        stakeManager = IStakeManager(stakeManagerAddress);
        blameManager = IBlameManager(blameManagerAddress);
    }

    /**
     * @notice validator take part in the selection process to be part of the active set
     * @dev Before taking part in the selection process iteration, if there are validators
     * in the previous active set, we churn out validators (check _churnOut internal funtion for details)
     * is calculated off chain by the validator nodes then is used to select a validator in a bias
     * way using _isElectedProposer(). This function can be called only once every dynasty
     * @param iteration iteration of validator with maximum of maxIteration
     * @param biggestValidatorId validatorId of the validator with biggest stake
     */
    function validatorSelection(uint256 iteration, uint32 biggestValidatorId) external {
        if (_getMode() != uint8(EpochMode.ValidatorSelection)) revert IncorrectMode();
        uint32 validatorId = stakeManager.getValidatorId(msg.sender);
        uint256 validatorStake = stakeManager.getStake(validatorId);
        uint256 biggestValidatorStake = stakeManager.getStake(biggestValidatorId);
        if (validatorId == 0) revert InvalidValidator();
        if (validatorStake < minStake) revert LessThanMinStake(validatorStake);

        uint256 dynasty = getDynasty();
        uint256 epoch = getEpoch();
        //slither-disable-next-line timestamp
        if (stakeManager.getValidatorJailEndDynasty(validatorId) > dynasty) revert ValidatorInJailPeriod();

        //slither-disable-next-line timestamp
        if (validatorIterationPerDynasty[validatorId][dynasty] != 0) revert IterationAlreadyCalculated();

        {
            uint8 validatorsChurnedOut = _churnOut(dynasty);

            // update the num participants for the current dynasty. If value already updated then ignore
            if (numParticipantsPerDynasty[dynasty] == 0) {
                // set the number of participants required in the current dynasty
                numParticipantsPerDynasty[dynasty] = numParticipants;
            }

            // After churning if the validator has been selected or churned out for the current dynasty then return
            // Churned out validators are not allowed to take part in the validtaor selection process of the current dyansty
            if (isValidatorSelectedPerDynasty[validatorId][dynasty] || isChurnedOut[dynasty][validatorId]) {
                if (validatorsChurnedOut > 0) {
                    emit ValidatorsChurnedOut(churnedOutValidators[dynasty], epoch, dynasty);
                    blameManager.setBlamePointsToZero(churnedOutValidators[dynasty]);
                }
                return;
            }

            // Will only do this calculation if the validator has not been selected in the previous dynasty
            // and the active set was complete in the previous dynasty

            salt = keccak256(abi.encodePacked(dynasty, activeSetPerDynasty[dynasty - 1]));

            if (!_isElectedProposer(iteration, validatorId, biggestValidatorStake, validatorStake)) revert NotElected();

            validatorIterationPerDynasty[validatorId][dynasty] = iteration;

            bool isAdded = _insertAppropriately(validatorId, iteration, biggestValidatorStake, dynasty);

            if (validatorsChurnedOut > 0) {
                emit ValidatorsChurnedOut(churnedOutValidators[dynasty], epoch, dynasty);
                blameManager.setBlamePointsToZero(churnedOutValidators[dynasty]);
            }

            if (isAdded) {
                emit ValidatorSelection(
                    validatorId,
                    activeSetPerDynasty[dynasty],
                    iteration,
                    biggestStakePerDynasty[dynasty],
                    isValidatorSelectedPerDynasty[validatorId][dynasty],
                    epoch,
                    dynasty
                    );
            }
        }
    }

    /**
     * @notice each validator is required to send their attestation of the public signing address
     * that is generated off chain by the validator nodes. Once the votes of a particular signer address exceeds the threshold,
     * that address is set as public signing address for the rest of the dynasty
     * @param signerAddress address of the public signing address that is being attested by the validator
     */
    function attestSigner(address signerAddress) external {
        // signer checks
        if (_getMode() != uint8(EpochMode.SignerCreation)) revert IncorrectMode();
        uint32 validatorId = stakeManager.getValidatorId(msg.sender);
        if (validatorId == 0) revert InvalidValidator();

        uint256 dynasty = getDynasty();
        if (!isValidatorSelectedPerDynasty[validatorId][dynasty]) revert ValidatorNotSelected();

        if (signerAddress == address(0)) revert ZeroSignerAddress();

        uint256 epoch = getEpoch();
        //slither-disable-next-line timestamp
        if (signerAttestations[validatorId][dynasty][epoch].validatorId != 0) revert AlreadyAttested();

        signerVotesPerAttestation[dynasty][epoch][signerAddress] = signerVotesPerAttestation[dynasty][epoch][signerAddress] + 1;
        signerAttestations[validatorId][dynasty][epoch] = Structs.SignerAttestation(validatorId, signerAddress);

        // registering vote on public key if passed threshold
        if (signerVotesPerAttestation[dynasty][epoch][signerAddress] > threshold) {
            attestedSignerAddress[dynasty][epoch] = signerAddress;
        }

        emit AttestSigner(signerAddress, validatorId, msg.sender, epoch, dynasty);
    }

    /**
     * @notice previous set of validators who created the signerAddress (public sigining address) for the previous dynasty
     * have to transfer ownership to the new signerAddress attested by the new set of validators of the current dynasty
     * by creating a signature on the new signerAddress
     * @dev signature is created by signing the (currentEpoch, newSignerAddress) using the previous signerAddress.
     * There is a condition where the admin can create the signature if there is no previous signerAddress available
     * for the validators to sign with
     * @param signature signature proof created by the previous signerAddress
     */
    function confirmSigner(bytes memory signature) external {
        if (_getMode() != uint8(EpochMode.SignerCreation)) revert IncorrectMode();

        uint256 dynasty = getDynasty();
        uint256 epoch = getEpoch();
        //slither-disable-next-line timestamp
        if (signerAddressPerDynasty[dynasty][epoch] != address(0)) revert SignerAlreadyConfirmed();
        if (attestedSignerAddress[dynasty][epoch] == address(0)) revert ZeroSignerAddress();
        address signerAddress = attestedSignerAddress[dynasty][epoch];
        bytes32 messageHash = keccak256(abi.encodePacked(epoch, signerAddress));
        if (hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {
            //slither-disable-next-line incorrect-equality,timestamp
            if (ECDSA.recover(messageHash, signature) != msg.sender) revert InvalidSignature();
        } else {
            //slither-disable-next-line incorrect-equality,timestamp
            if (ECDSA.recover(messageHash, signature) != signerAddressPerDynasty[dynasty - 1][modeChange[dynasty - 1]]) {
                revert InvalidSignature();
            }
        }

        signerTransferProofs[dynasty] = Structs.SignerTransfer(signerAddress, epoch, signature);
        signerAddressPerDynasty[dynasty][epoch] = signerAddress;
        modeChange[dynasty] = epoch;

        emit ConfirmTransfer(
            signature,
            signerAddressPerDynasty[dynasty - 1][modeChange[dynasty - 1]],
            signerAddressPerDynasty[dynasty][modeChange[dynasty]],
            epoch,
            dynasty
            );
    }

    /**
     * @notice validators commit the message that they want to finalize. The message with votes greater than the threshold is
     * set as the message for the current epoch
     * @dev messageData consists of currentDynasty, currentEpoch, requestIds to be fulfilled with a maximum of maxRequests
     * and values which will be mapped to each requestId respectively. If there are no pending requests,
     * values and requestIds should be empty so that an empty block can be finalized by the active set
     * @param messageData the message validator is committing
     */
    function commitMessage(bytes calldata messageData) external {
        if (_getMode() != uint8(EpochMode.Signing)) revert IncorrectMode();

        uint256 dynasty = getDynasty();
        uint256 epoch = getEpoch();
        uint32 validatorId = stakeManager.getValidatorId(msg.sender);
        //slither-disable-next-line timestamp
        if (bytes32(blocks[epoch].signature) != bytes32(0)) revert BlockAlreadyConfirmed();
        //slither-disable-next-line timestamp
        if (hasValidatorCommitMessage[validatorId][dynasty][epoch]) revert ValidatorAlreadyCommitted();
        //slither-disable-next-line timestamp
        if (!isValidatorSelectedPerDynasty[validatorId][dynasty]) revert ValidatorNotSelected();
        (uint256 _dynasty, uint256 _epoch, uint32[] memory requestIds, bytes[] memory values) =
            abi.decode(messageData, (uint256, uint256, uint32[], bytes[]));
        //slither-disable-next-line incorrect-equality,timestamp
        if (_dynasty != dynasty) revert InvalidDynastyInMessageData(dynasty, _dynasty);
        if (_epoch != epoch) revert InvalidEpochInMessageData(epoch, _epoch);
        if (requestIds.length > maxRequests) revert TooManyRequests();
        if (values.length != requestIds.length) revert InvalidMessage();

        //Propose an empty block if no pending requests
        if (numRequestsFulfilled == numRequests) {
            if (values.length != 0) revert EmptyMessageExpected();
        } else {
            if (values.length == 0) revert InvalidMessage();
        }

        if (requestIds.length != 0) {
            for (uint32 i = 0; i < requestIds.length; i++) {
                uint32 requestId = requestIds[i];
                if (requestId == 0) revert RequestIdCantBeZero();
                if (requests[requestId].fulfilled) revert RequestAlreadyFulfilled(requestId);
                if (requests[requestId].epoch >= epoch) revert IncorrectRequestEpoch(epoch, requests[requestId].epoch);
                if (i != 0) {
                    if (requestId <= requestIds[i - 1]) revert RequestIdsNotInOrder();
                }
            }
            if (requestIds[0] != 1) {
                if (!requests[requestIds[0] - 1].fulfilled) revert PreviousRequestNotFulfilled();
            }
        }

        bytes32 messageHash = keccak256(messageData);

        numMessageVotesPerEpoch[dynasty][epoch][messageHash] = numMessageVotesPerEpoch[dynasty][epoch][messageHash] + 1;
        hasValidatorCommitMessage[validatorId][dynasty][epoch] = true;

        // registering vote on message if passed threshold
        if (numMessageVotesPerEpoch[dynasty][epoch][messageHash] > threshold) {
            messagePerEpoch[dynasty][epoch] = messageHash;
        }

        emit MessageCommitted(messageData, validatorId, msg.sender, epoch, dynasty);
    }

    /**
     * @notice Once the signature has been generated by the validators for a particular message,
     * a validator can call this function which will verify the signature created with the message that is to be bridged (finalized)
     * and a validator from the active set is randomly selected and rewarded with a blockReward
     * @dev The message has to be encoded and then sent to the contracts. Encoding is to be done in the following pattern:
     * dynasty(uint256), epoch(uint256), requestId(uint32[]), values(bytes[])
     * @param signature messageData signed by the current dynasty public signing address
     * @param messageData the message that is to be bridged
     */
    function finalizeBlock(bytes calldata signature, bytes calldata messageData) external {
        if (_getMode() != uint8(EpochMode.Signing)) revert IncorrectMode();

        uint256 dynasty = getDynasty();

        uint256 epoch = getEpoch();

        if (bytes32(blocks[epoch].signature) == bytes32(0)) {
            bytes32 messageHash = keccak256(messageData);
            //slither-disable-next-line timestamp
            if (messagePerEpoch[dynasty][epoch] == bytes32(0)) revert NoMessageCommitted();
            //slither-disable-next-line timestamp
            if (messagePerEpoch[dynasty][epoch] != messageHash) revert InvalidMessage();
            //slither-disable-next-line timestamp
            if (ECDSA.recover(messageHash, signature) != signerAddressPerDynasty[dynasty][modeChange[dynasty]]) revert InvalidSignature();

            (,, uint32[] memory requestIds,) = abi.decode(messageData, (uint256, uint256, uint32[], bytes[]));

            blocks[epoch] = Structs.Block(block.timestamp, messageData, signature);

            //Fulfill the pending requests based on the messageData's requestIds
            {
                uint32 _numRequestsFulfilled;
                for (uint32 i = 0; i < requestIds.length; i++) {
                    requests[requestIds[i]].fulfilled = true;
                    _numRequestsFulfilled++;
                }
                numRequestsFulfilled += _numRequestsFulfilled;
            }

            uint32 selectedValidator = _selectValidator(dynasty);

            emit FinalizeBlock(
                selectedValidator, signature, signerAddressPerDynasty[dynasty][modeChange[dynasty]], messageData, msg.sender, epoch, dynasty
                );

            stakeManager.giveBlockReward(selectedValidator);
        }
    }

    /**
     * @notice sets the base epoch and time increment when skipping a dynasty
     * @param _baseEpochIncrement base epochs to be incremented
     * @param _baseTimeIncrement base time to be incrememented
     */
    function updateBaseParameters(uint256 _baseEpochIncrement, uint256 _baseTimeIncrement) external onlyRole(BASE_MODIFIER_ROLE) {
        baseTimeIncrement = _baseTimeIncrement;
        baseEpochIncrement = _baseEpochIncrement;
    }

    function setIsSignerDisputed(uint256 dynasty) external onlyRole(SET_DISPUTED_ROLE) {
        isSignerDisputed[signerAddressPerDynasty[dynasty][modeChange[dynasty]]] = true;
    }

    /**
     * @notice this threshold(T) value is used by the network to reach consensus (T + 1) on the public singing address and
     * the message to be finalized by the validator nodes. T needs to be less than the number of participants
     * @param _threshold threshold value to be set for the network
     */
    function setThreshold(uint32 _threshold) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (_getMode() != uint8(EpochMode.ValidatorSelection)) revert IncorrectMode();
        if (_threshold >= numParticipants) revert InvalidUpdation();
        threshold = _threshold;
    }

    /**
     * @notice the number of participants in the network should always be greater than the threshold(T) for the network to reach consensus
     * @param _numParticipants sets the number of participants N allowed in the network
     */
    function setNumParticipants(uint32 _numParticipants) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (_getMode() == uint8(EpochMode.ValidatorSelection)) revert IncorrectMode();
        numParticipants = _numParticipants;
    }

    function setSupportedChainId(uint256 _chainId, bool _status) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (isChainSupported[_chainId] == _status) revert ChainStatusAlreadySet();
        uint256 dynasty = getDynasty();
        uint256 epoch = getEpoch();
        isChainSupported[_chainId] = _status;
        emit ChainStatus(_chainId, _status, msg.sender, epoch, dynasty);
    }

    function getSignerAddress(uint256 dynasty) external view override returns (address) {
        return signerAddressPerDynasty[dynasty][modeChange[dynasty]];
    }

    function getSignerTransferProof(uint256 dynasty) external view override returns (Structs.SignerTransfer memory) {
        return signerTransferProofs[dynasty];
    }

    function getChurnedOutValidatorsPerDynasty(uint256 dynasty) external view returns (uint32[] memory) {
        return churnedOutValidators[dynasty];
    }

    /**
     * @param validatorId id of the validator
     * @param dynasty dynasty for which iteration is to be fetched
     * @return iteration of the validator in the selected dynasty
     */
    function getValidatorIteration(uint32 validatorId, uint256 dynasty) external view override returns (uint256) {
        return validatorIterationPerDynasty[validatorId][dynasty];
    }

    /**
     * @param validatorId id of the validator
     * @param dynasty dynasty to check if validator is part of active set
     * @return boolean to confirm if validatorId is part of the active set in the selected dynasty
     */
    function getIsValidatorSelectedPerDynasty(uint32 validatorId, uint256 dynasty) external view override returns (bool) {
        return isValidatorSelectedPerDynasty[validatorId][dynasty];
    }

    /**
     * @notice returns an array of validatorIds active in the current dynasty
     * @param dynasty dynasty to check for active set
     * @return activeSetPerDynasty array of validatorIds
     */
    function getActiveSetPerDynasty(uint256 dynasty) external view override returns (uint32[] memory) {
        return activeSetPerDynasty[dynasty];
    }

    /**
     * @notice used to query the number of participants (N) that being selected in the provided dynasty
     * @return numParticipants
     */
    function getNumParticipantsPerDynasty(uint256 dynasty) external view override returns (uint32) {
        if (numParticipantsPerDynasty[dynasty] == 0) {
            return numParticipants;
        }

        return numParticipantsPerDynasty[dynasty];
    }

    /**
     * @notice used to query the threshold set for the network
     * @return threshold
     */
    function getThreshold() external view override returns (uint32) {
        return threshold;
    }

    /**
     * @notice used to query the current mode (state) of the network
     * @dev external function that interacts with an internal function, so that getMode can be used by other contracts
     * @return mode _getMode() calculates the current mode
     */
    function getMode() external view override returns (uint8 mode) {
        return _getMode();
    }

    /**
     * @notice used to query the current mode (state) of the network
     * @dev internal function that calculates the mode based on factors like epoch, dynasty, numParticipants and activeSetPerDynasty
     * @return mode
     */
    function _getMode() internal view returns (uint8 mode) {
        uint256 dynasty = getDynasty();
        uint256 epoch = getEpoch();
        uint32 _numParticipants = numParticipantsPerDynasty[dynasty];
        if (_numParticipants == 0) {
            _numParticipants = numParticipants;
        }

        if (
            epoch <= (validatorSelectionTimelimit + ((dynasty - 1) * dynastyLength))
                || activeSetPerDynasty[dynasty].length < _numParticipants
        ) {
            return uint8(EpochMode.ValidatorSelection);
        }
        //slither-disable-next-line incorrect-equality,timestamp
        else if (modeChange[dynasty] == 0 || modeChange[dynasty] == epoch) {
            return uint8(EpochMode.SignerCreation);
        } else {
            return uint8(EpochMode.Signing);
        }
    }

    /**
     * @notice calculates whether or not a validator should be selected for the active set of the current dynasty
     * @dev internal function that selects validator in a biased selection, iteration is calculated off chain by
     * the validator nodes
     * @return bool that indicates whether a validator is selected in the active set of the current dynasty
     */
    function _isElectedProposer(uint256 iteration, uint32 validatorId, uint256 biggestStake, uint256 validatorStake)
        internal
        view
        returns (bool)
    {
        // generating pseudo random number (range 0..(totalstake - 1)), add (+1) to the result,
        // since prng returns 0 to max-1 and staker start from 1
        //roll an n sided fair die where n == numStakers to select a staker pseudoRandomly
        bytes32 seed1 = Random.prngHash(salt, keccak256(abi.encode(iteration)));
        uint256 rand1 = Random.prng(stakeManager.getNumValidators(), seed1);
        //slither-disable-next-line timestamp
        if ((rand1 + 1) != validatorId) {
            return false;
        }
        //toss a biased coin with increasing iteration till the following equation returns true.
        // stake/biggest stake >= prng(iteration,stakerid, salt), staker wins
        // stake/biggest stake < prng(iteration,stakerid, salt), staker loses
        // simplified equation:- stake < prng * biggestStake
        // stake * 2^32 < prng * 2^32 * biggestStake
        // multiplying by 2^32 since seed2 is bytes32 so rand2 goes from 0 to 2^32
        bytes32 seed2 = Random.prngHash(salt, keccak256(abi.encode(validatorId, iteration)));
        uint256 rand2 = Random.prng(2 ** 32, seed2);

        // Below line can't be tested since it can't be assured if it returns true or false
        if (rand2 * (biggestStake) > validatorStake * (2 ** 32)) return (false);
        return true;
    }

    /**
     * @notice randomly selects a validator from the active set of the current dynasty
     * @dev internal function that selects validator in a random fashion from activeSetPerDynasty, this validator is
     * selected to finalize the block and receives the block reward
     */
    function _selectValidator(uint256 dynasty) internal view returns (uint32 selectedValidator) {
        uint256 randVal = Random.prng(activeSetPerDynasty[dynasty].length, blockhash(block.number - 1));
        selectedValidator = activeSetPerDynasty[dynasty][randVal];
    }

    /**
     * @notice churns out validator from the active validator set
     * @dev order of churning out is:-
     * Step 1. If any validator has called unstake and their withdraw lock is about to unlock this dynasty, then churn them out
     * but maximum only 1/3rd of the activeSet can be churned out at a time
     * Step 2. we churn out a validator randomly
     */
    function _churnOut(uint256 dynasty) internal returns (uint8) {
        uint8 validatorsChurnedOut = 0;
        if (churnedOutValidators[dynasty].length == 0) {
            if (
                activeSetPerDynasty[dynasty - 1].length < numParticipantsPerDynasty[dynasty - 1]
                    || activeSetPerDynasty[dynasty - 1].length == 0
                    || isSignerDisputed[signerAddressPerDynasty[dynasty - 1][modeChange[dynasty - 1]]]
            ) return 0;

            uint32 numValidatorsToChurnOut = (numParticipants * maxChurnPercentage) / BASE_DENOMINATOR;

            {
                uint32[] memory bannedValidators = new uint32[](numParticipants);
                uint32[] memory unstakingValidators = new uint32[](numParticipants);
                uint32[] memory highPenaltyValidators = new uint32[](numParticipants);

                uint32 numBanned = 0;
                uint32 numUnstake = 0;
                uint32 numHighPen = 0;

                // Step 1: Add validators to the active set that do not required to be churned out
                for (uint256 i = 0; i < activeSetPerDynasty[dynasty - 1].length; ++i) {
                    uint32 id = activeSetPerDynasty[dynasty - 1][i];
                    uint256 withdrawAfter = stakeManager.getWithdrawAfterPerValidator(id);
                    uint16 validatorPenaltyPoints = blameManager.getBlamePointsPerValidator(id);
                    //slither-disable-next-line timestamp
                    if (validatorPenaltyPoints < THRESHOLD_POINTS && (withdrawAfter > dynasty || withdrawAfter == 0)) {
                        _addToActiveSet(dynasty, id);
                        continue;
                    }

                    if (validatorPenaltyPoints == MAX_POINTS) {
                        bannedValidators[numBanned] = id;
                        numBanned += 1;
                    }
                    //slither-disable-next-line timestamp
                    else if (withdrawAfter <= dynasty && withdrawAfter != 0) {
                        unstakingValidators[numUnstake] = id;
                        numUnstake += 1;
                    } else if (validatorPenaltyPoints >= THRESHOLD_POINTS) {
                        highPenaltyValidators[numHighPen] = id;
                        numHighPen += 1;
                    }
                }

                // Step 2: Churn out banned validators
                for (uint256 i = 0; i < numBanned; ++i) {
                    uint32 id = bannedValidators[i];
                    if (validatorsChurnedOut == numValidatorsToChurnOut) {
                        _addToActiveSet(dynasty, id);
                        continue;
                    }

                    churnedOutValidators[dynasty].push(id);
                    isChurnedOut[dynasty][id] = true;
                    isValidatorSelectedPerDynasty[id][dynasty] = false;
                    validatorsChurnedOut++;
                    // slither-disable-next-line reentrancy-events,reentrancy-no-eth,reentrancy-benign
                    stakeManager.jailValidator(id);
                }

                // Step 3: Churn out unstake validators
                if (validatorsChurnedOut == numValidatorsToChurnOut) {
                    for (uint256 i = 0; i < numUnstake; ++i) {
                        _addToActiveSet(dynasty, unstakingValidators[i]);
                        continue;
                    }
                } else {
                    for (uint256 i = 0; i < numUnstake; ++i) {
                        uint32 id = unstakingValidators[i];

                        if (validatorsChurnedOut == numValidatorsToChurnOut) {
                            _addToActiveSet(dynasty, id);
                            continue;
                        }

                        churnedOutValidators[dynasty].push(id);
                        isChurnedOut[dynasty][id] = true;
                        isValidatorSelectedPerDynasty[id][dynasty] = false;
                        validatorsChurnedOut++;
                    }
                }

                // Step 4: Churn out randomly churned validator
                if (validatorsChurnedOut != numValidatorsToChurnOut) {
                    uint256 randVal = Random.prng(activeSetPerDynasty[dynasty].length + numHighPen, blockhash(block.number - 1));
                    uint32 randomChurn;
                    if (randVal < activeSetPerDynasty[dynasty].length) {
                        randomChurn = activeSetPerDynasty[dynasty][randVal];
                        activeSetPerDynasty[dynasty][randVal] = activeSetPerDynasty[dynasty][activeSetPerDynasty[dynasty].length - 1];
                        activeSetPerDynasty[dynasty].pop();
                        isValidatorSelectedPerDynasty[randomChurn][dynasty] = false;
                    } else {
                        randomChurn = highPenaltyValidators[randVal - activeSetPerDynasty[dynasty].length];
                    }
                    churnedOutValidators[dynasty].push(randomChurn);
                    isChurnedOut[dynasty][randomChurn] = true;
                    validatorsChurnedOut++;
                }

                // Step 5: Churn out high penalty validator
                if (validatorsChurnedOut == numValidatorsToChurnOut || numBanned != 0) {
                    for (uint256 i = 0; i < numHighPen; ++i) {
                        if (isChurnedOut[dynasty][highPenaltyValidators[i]]) continue;

                        _addToActiveSet(dynasty, highPenaltyValidators[i]);
                        continue;
                    }
                } else {
                    for (uint256 i = 0; i < numHighPen; ++i) {
                        uint32 id = highPenaltyValidators[i];

                        if (isChurnedOut[dynasty][id]) continue;

                        if (validatorsChurnedOut == numValidatorsToChurnOut) {
                            _addToActiveSet(dynasty, id);
                            continue;
                        }

                        churnedOutValidators[dynasty].push(id);
                        isChurnedOut[dynasty][id] = true;
                        validatorsChurnedOut++;
                    }
                }
            }

            return validatorsChurnedOut;
        }
        return 0;
    }

    function _addToActiveSet(uint256 dynasty, uint32 id) internal {
        isValidatorSelectedPerDynasty[id][dynasty] = true;
        activeSetPerDynasty[dynasty].push(id);
    }

    /**
     * @dev inserts the validator in the approporiate place based on the iteration of the validator. The validator
     * with the lowest iteration is given a higher priority
     * @param validatorId id of the validator
     * @param iteration iteration calculated off chain by validator nodes
     * @param biggestValidatorStake the stake of the validator with the largest stake
     * @param dynasty current dynasty
     * @return isAdded : whether the validator was added to the active set
     */
    function _insertAppropriately(uint32 validatorId, uint256 iteration, uint256 biggestValidatorStake, uint256 dynasty)
        internal
        returns (bool isAdded)
    {
        uint8 activeSetPerDynastylength = uint8(activeSetPerDynasty[dynasty].length);
        uint8 churnedOutValidatorslength = uint8(churnedOutValidators[dynasty].length);
        uint8 numValidatorsAlreadySelected = 0;

        if (churnedOutValidatorslength != 0) {
            numValidatorsAlreadySelected = uint8(numParticipantsPerDynasty[dynasty] - churnedOutValidatorslength);
        }

        if (activeSetPerDynastylength == numValidatorsAlreadySelected) {
            activeSetPerDynasty[dynasty].push(validatorId);
            isValidatorSelectedPerDynasty[validatorId][dynasty] = true;
            biggestStakePerDynasty[dynasty] = biggestValidatorStake;
            return true;
        }

        if (biggestStakePerDynasty[dynasty] > biggestValidatorStake) {
            return false;
        }

        if (biggestStakePerDynasty[dynasty] < biggestValidatorStake) {
            for (uint8 i = activeSetPerDynastylength; i > numValidatorsAlreadySelected; i--) {
                isValidatorSelectedPerDynasty[activeSetPerDynasty[dynasty][i - 1]][dynasty] = false;
                activeSetPerDynasty[dynasty].pop();
            }
            activeSetPerDynasty[dynasty].push(validatorId);
            isValidatorSelectedPerDynasty[validatorId][dynasty] = true;
            biggestStakePerDynasty[dynasty] = biggestValidatorStake;

            return true;
        }

        for (uint8 i = numValidatorsAlreadySelected; i < activeSetPerDynastylength; i++) {
            if (validatorIterationPerDynasty[activeSetPerDynasty[dynasty][i]][dynasty] > iteration) {
                activeSetPerDynasty[dynasty].push(validatorId);
                isValidatorSelectedPerDynasty[validatorId][dynasty] = true;

                activeSetPerDynastylength = activeSetPerDynastylength + 1;

                for (uint256 j = activeSetPerDynastylength - 1; j > i; j--) {
                    activeSetPerDynasty[dynasty][j] = activeSetPerDynasty[dynasty][j - 1];
                }

                activeSetPerDynasty[dynasty][i] = validatorId;

                if (activeSetPerDynasty[dynasty].length > numParticipantsPerDynasty[dynasty]) {
                    isValidatorSelectedPerDynasty[activeSetPerDynasty[dynasty][activeSetPerDynasty[dynasty].length - 1]][dynasty] = false;
                    activeSetPerDynasty[dynasty].pop();
                }

                return true;
            }
        }
        // Worst Iteration and for all other blocks, influence was >=
        if (activeSetPerDynasty[dynasty].length < numParticipantsPerDynasty[dynasty]) {
            activeSetPerDynasty[dynasty].push(validatorId);
            isValidatorSelectedPerDynasty[validatorId][dynasty] = true;

            return true;
        }
    }
}
